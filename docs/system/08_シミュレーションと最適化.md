# 08_ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¨æœ€é©åŒ–

**æœ€çµ‚æ›´æ–°æ—¥**: 2025-11-18

---

## ğŸ“‘ ç›®æ¬¡

1. [ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³](#ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³)
2. [ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªæœ€é©åŒ–](#ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªæœ€é©åŒ–)
3. [å®Ÿè£…è©³ç´°](#å®Ÿè£…è©³ç´°)
4. [ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°](#ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°)

---

## ğŸ² ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

### ç›®çš„

Î¼, Ïƒ, Î½ã‹ã‚‰**å„é¦¬ã®å‹ç‡**ã‚’æ¨å®š

### ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

```python
for k = 1 to K (K=1000):
    for horse_i in race:
        # tåˆ†å¸ƒã‹ã‚‰ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
        time_i_k ~ t_Î½(Î¼_i, Ïƒ_iÂ²)

    # ç€é †æ±ºå®š
    finish_order = argsort(times)

    # å‹è€…è¨˜éŒ²
    winner_counts[finish_order[0]] += 1

# å‹ç‡æ¨å®š
P(win) = winner_counts / K
```

### å®Ÿè£…ï¼ˆRaceSimulatorï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `keibaai/src/modules/sim/simulator.py`

```python
import numpy as np
from scipy.stats import t

class RaceSimulator:
    def __init__(self, K=1000):
        """
        Args:
            K: ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°
        """
        self.K = K

    def simulate(
        self,
        mu_array: np.ndarray,
        sigma_array: np.ndarray,
        nu: float
    ) -> dict:
        """
        ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

        Args:
            mu_array: å„é¦¬ã®æœŸå¾…å®Œèµ°æ™‚é–“ [N]
            sigma_array: å„é¦¬ã®æ¨™æº–åå·® [N]
            nu: ãƒ¬ãƒ¼ã‚¹å…¨ä½“ã®è‡ªç”±åº¦

        Returns:
            dict: {
                'win_probs': [N],
                'place_probs': [N],
                'show_probs': [N]
            }
        """
        N = len(mu_array)
        win_counts = np.zeros(N)
        place_counts = np.zeros(N)  # 2ç€ä»¥å†…
        show_counts = np.zeros(N)   # 3ç€ä»¥å†…

        for k in range(self.K):
            # å„é¦¬ã®å®Œèµ°æ™‚é–“ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
            finish_times = np.array([
                t.rvs(df=nu, loc=mu_i, scale=sigma_i)
                for mu_i, sigma_i in zip(mu_array, sigma_array)
            ])

            # ç€é †æ±ºå®š
            finish_order = np.argsort(finish_times)

            # ã‚«ã‚¦ãƒ³ãƒˆ
            win_counts[finish_order[0]] += 1
            place_counts[finish_order[:2]] += 1
            show_counts[finish_order[:3]] += 1

        # ç¢ºç‡æ¨å®š
        win_probs = win_counts / self.K
        place_probs = place_counts / self.K
        show_probs = show_counts / self.K

        return {
            'win_probs': win_probs,
            'place_probs': place_probs,
            'show_probs': show_probs
        }
```

### é«˜é€ŸåŒ–ç‰ˆï¼ˆNumPyãƒ™ã‚¯ãƒˆãƒ«åŒ–ï¼‰

```python
def simulate_vectorized(
    self,
    mu_array: np.ndarray,
    sigma_array: np.ndarray,
    nu: float
) -> dict:
    """ãƒ™ã‚¯ãƒˆãƒ«åŒ–ç‰ˆï¼ˆ10-20xé«˜é€Ÿï¼‰"""

    N = len(mu_array)

    # ä¸€åº¦ã«å…¨ã‚µãƒ³ãƒ—ãƒ«ç”Ÿæˆ [K x N]
    finish_times_all = np.array([
        t.rvs(df=nu, loc=mu_array, scale=sigma_array, size=self.K)
        for _ in range(N)
    ]).T

    # ç€é †æ±ºå®š [K x N]
    finish_orders = np.argsort(finish_times_all, axis=1)

    # ã‚«ã‚¦ãƒ³ãƒˆ
    win_counts = np.bincount(finish_orders[:, 0], minlength=N)
    place_counts = np.bincount(finish_orders[:, :2].flatten(), minlength=N)
    show_counts = np.bincount(finish_orders[:, :3].flatten(), minlength=N)

    win_probs = win_counts / self.K
    place_probs = place_counts / self.K
    show_probs = show_counts / self.K

    return {
        'win_probs': win_probs,
        'place_probs': place_probs,
        'show_probs': show_probs
    }
```

### ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã®ä¿å­˜

```json
{
  "race_id": "202310010811",
  "race_date": "2023-10-01",
  "K": 1000,
  "nu": 5.2,
  "horses": [
    {
      "horse_number": 1,
      "horse_name": "ã‚µãƒ³ãƒ—ãƒ«ãƒ›ãƒ¼ã‚¹1",
      "mu": 72.3,
      "sigma": 1.2,
      "win_prob": 0.352,
      "place_prob": 0.681,
      "show_prob": 0.854
    },
    {
      "horse_number": 2,
      "horse_name": "ã‚µãƒ³ãƒ—ãƒ«ãƒ›ãƒ¼ã‚¹2",
      "mu": 73.1,
      "sigma": 2.1,
      "win_prob": 0.118,
      "place_prob": 0.384,
      "show_prob": 0.602
    },
    ...
  ]
}
```

---

## ğŸ’° ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªæœ€é©åŒ–

### Kelly Criterionï¼ˆã‚±ãƒªãƒ¼åŸºæº–ï¼‰

**ç™ºæ˜è€…**: John L. Kelly Jr. (1956)

**åŸºæœ¬å…¬å¼**:
```
f* = (p * (o - 1) - (1 - p)) / (o - 1)

where:
  f*: è³‡ç”£ã®ä½•å‰²ã‚’è³­ã‘ã‚‹ã‹
  p:  å‹ç‡
  o:  ã‚ªãƒƒã‚º
```

**ä¾‹**:
```python
p = 0.35  # 35%ã®å‹ç‡
o = 3.2   # 3.2å€ã®ã‚ªãƒƒã‚º

f_star = (0.35 * (3.2 - 1) - (1 - 0.35)) / (3.2 - 1)
       = (0.35 * 2.2 - 0.65) / 2.2
       = (0.77 - 0.65) / 2.2
       = 0.055  # â†’ è³‡ç”£ã®5.5%ã‚’è³­ã‘ã‚‹
```

### Fractional Kellyï¼ˆãƒªã‚¹ã‚¯èª¿æ•´ç‰ˆï¼‰

**å•é¡Œ**: Full Kellyã¯ç©æ¥µçš„ã™ãã‚‹ â†’ ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ãŒå¤§ãã„

**è§£æ±º**: Kelly fractionã§ç¸®å°

```python
f_actual = f_star * kelly_fraction

# kelly_fraction ã®æ¨å¥¨å€¤:
# 0.25: ä¿å®ˆçš„ï¼ˆæ¨å¥¨ï¼‰
# 0.50: æ¨™æº–
# 1.00: ãƒ•ãƒ«ã‚±ãƒªãƒ¼ï¼ˆãƒªã‚¹ã‚¯å¤§ï¼‰
```

### Multi-Horse Portfolio Optimization

**æœ€é©åŒ–å•é¡Œ**:
```
Maximize: Î£ f_i * log(1 + (o_i - 1) * f_i / W_0)

Subject to:
  Î£ f_i â‰¤ W_0          # è³‡æœ¬åˆ¶ç´„
  f_i â‰¥ 0              # éè² åˆ¶ç´„
  EV_i > threshold     # æœŸå¾…å€¤ãƒ•ã‚£ãƒ«ã‚¿

where:
  f_i: é¦¬iã¸ã®è³­ã‘é‡‘
  o_i: é¦¬iã®ã‚ªãƒƒã‚º
  W_0: ç·è³‡æœ¬
  EV_i = p_i * o_i - 1  # æœŸå¾…å€¤
```

### å®Ÿè£…ï¼ˆPortfolioOptimizerï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `keibaai/src/modules/optimizer/optimizer.py`

```python
from scipy.optimize import minimize

class PortfolioOptimizer:
    def __init__(self, kelly_fraction=0.25, ev_threshold=0.05):
        """
        Args:
            kelly_fraction: KellyåŸºæº–ã®ç¸®å°ç‡
            ev_threshold: è³­ã‘ã‚’æ¤œè¨ã™ã‚‹æœ€å°æœŸå¾…å€¤
        """
        self.kelly_fraction = kelly_fraction
        self.ev_threshold = ev_threshold

    def optimize_kelly(
        self,
        win_probs: np.ndarray,
        odds: np.ndarray,
        capital: float
    ) -> np.ndarray:
        """
        Fractional Kelly Criterionã«ã‚ˆã‚‹æœ€é©åŒ–

        Args:
            win_probs: å„é¦¬ã®å‹ç‡ [N]
            odds: å„é¦¬ã®ã‚ªãƒƒã‚º [N]
            capital: ç·è³‡æœ¬

        Returns:
            optimal_bets: æœ€é©ãªè³­ã‘é‡‘é…åˆ† [N]
        """
        N = len(win_probs)

        # æœŸå¾…å€¤ãƒ•ã‚£ãƒ«ã‚¿
        ev = win_probs * odds - 1
        valid_mask = ev > self.ev_threshold

        if not valid_mask.any():
            # è³­ã‘ã‚‹ä¾¡å€¤ã®ã‚ã‚‹é¦¬ãŒã„ãªã„
            return np.zeros(N)

        # ç›®çš„é–¢æ•°ï¼ˆè² ã«ã—ã¦æœ€å°åŒ–å•é¡Œã«å¤‰æ›ï¼‰
        def objective(f):
            # Kelly utility function
            utility = np.sum(
                f * np.log(1 + (odds - 1) * f / capital + 1e-10)
            )
            return -utility

        # åˆ¶ç´„æ¡ä»¶
        constraints = [
            # ç·è³­ã‘é‡‘ â‰¤ è³‡æœ¬
            {'type': 'ineq', 'fun': lambda f: capital - np.sum(f)},
        ]

        # å¢ƒç•Œæ¡ä»¶ï¼ˆéè² åˆ¶ç´„ï¼‰
        bounds = [(0, capital) if valid_mask[i] else (0, 0) for i in range(N)]

        # åˆæœŸå€¤ï¼ˆEVãŒæ­£ã®é¦¬ã«å‡ç­‰é…åˆ†ï¼‰
        num_valid = valid_mask.sum()
        initial_guess = np.where(
            valid_mask,
            capital * 0.05,  # 5%ãšã¤
            0
        )

        # æœ€é©åŒ–å®Ÿè¡Œ
        result = minimize(
            objective,
            initial_guess,
            method='SLSQP',
            bounds=bounds,
            constraints=constraints
        )

        if not result.success:
            logging.warning(f"Optimization failed: {result.message}")
            return np.zeros(N)

        # Kelly fractionã§ãƒªã‚¹ã‚¯èª¿æ•´
        optimal_bets = result.x * self.kelly_fraction

        return optimal_bets
```

### æœ€é©åŒ–çµæœã®ä¾‹

```json
{
  "race_id": "202310010811",
  "capital": 100000,
  "kelly_fraction": 0.25,
  "ev_threshold": 0.05,
  "recommended_bets": [
    {
      "horse_number": 5,
      "horse_name": "ã‚µãƒ³ãƒ—ãƒ«ãƒ›ãƒ¼ã‚¹5",
      "win_prob": 0.352,
      "odds": 3.2,
      "expected_value": 0.126,
      "bet_amount": 8500,
      "expected_return": 9576
    },
    {
      "horse_number": 11,
      "horse_name": "ã‚µãƒ³ãƒ—ãƒ«ãƒ›ãƒ¼ã‚¹11",
      "win_prob": 0.118,
      "odds": 9.8,
      "expected_value": 0.156,
      "bet_amount": 3200,
      "expected_return": 3699
    }
  ],
  "total_bet": 11700,
  "expected_portfolio_return": 13275,
  "expected_roi": 1.135
}
```

---

## ğŸ’» å®Ÿè£…è©³ç´°

### æ—¥æ¬¡ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `keibaai/src/sim/simulate_daily_races.py`

```python
import argparse
from pathlib import Path
import pandas as pd
from modules.sim.simulator import RaceSimulator

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--date', required=True, help='YYYY-MM-DD')
    parser.add_argument('--K', type=int, default=1000)
    args = parser.parse_args()

    # äºˆæ¸¬çµæœèª­ã¿è¾¼ã¿
    predictions_path = Path(f"data/predictions/parquet/{args.date}_predictions.parquet")
    df = pd.read_parquet(predictions_path)

    # ãƒ¬ãƒ¼ã‚¹ã”ã¨ã«ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    simulator = RaceSimulator(K=args.K)

    for race_id in df['race_id'].unique():
        race_df = df[df['race_id'] == race_id]

        mu = race_df['mu_pred'].values
        sigma = race_df['sigma_pred'].values
        nu = race_df['nu_pred'].iloc[0]

        # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
        result = simulator.simulate(mu, sigma, nu)

        # ä¿å­˜
        output_path = Path(f"data/simulations/{race_id}.json")
        save_simulation_result(race_id, result, output_path)

if __name__ == '__main__':
    main()
```

### æ—¥æ¬¡æœ€é©åŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `keibaai/src/optimizer/optimize_daily_races.py`

```python
import argparse
from pathlib import Path
from modules.optimizer.optimizer import PortfolioOptimizer

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--date', required=True)
    parser.add_argument('--W_0', type=float, default=100000)
    args = parser.parse_args()

    # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœèª­ã¿è¾¼ã¿
    sim_dir = Path(f"data/simulations/")

    # JRAã‚ªãƒƒã‚ºå–å¾—ï¼ˆSeleniumï¼‰
    from modules.preparing import scrape_jra_odds
    odds_data = scrape_jra_odds(args.date)

    # æœ€é©åŒ–
    optimizer = PortfolioOptimizer(kelly_fraction=0.25)

    for race_id, sim_result in load_simulations(sim_dir, args.date):
        win_probs = sim_result['win_probs']
        odds = odds_data[race_id]['win_odds']

        # æœ€é©åŒ–å®Ÿè¡Œ
        optimal_bets = optimizer.optimize_kelly(win_probs, odds, args.W_0)

        # ä¿å­˜
        save_order(race_id, optimal_bets, f"data/orders/{race_id}_order.json")

if __name__ == '__main__':
    main()
```

---

## âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°

### ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯

| K | å®Ÿè£… | æ™‚é–“ï¼ˆç§’/ãƒ¬ãƒ¼ã‚¹ï¼‰ | å€é€Ÿ |
|---|------|-----------------|------|
| 1,000 | Pythonãƒ«ãƒ¼ãƒ— | 2.5 | 1x |
| 1,000 | NumPyãƒ™ã‚¯ãƒˆãƒ«åŒ– | 0.15 | 16.7x |
| 10,000 | NumPyãƒ™ã‚¯ãƒˆãƒ«åŒ– | 1.2 | - |

### ä¸¦åˆ—åŒ–ï¼ˆè¤‡æ•°ãƒ¬ãƒ¼ã‚¹ï¼‰

```python
from multiprocessing import Pool

def simulate_single_race(args):
    race_id, mu, sigma, nu = args
    simulator = RaceSimulator(K=1000)
    return race_id, simulator.simulate(mu, sigma, nu)

# ä¸¦åˆ—å®Ÿè¡Œ
with Pool(processes=4) as pool:
    results = pool.map(simulate_single_race, race_args_list)
```

### ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def simulate_cached(mu_tuple, sigma_tuple, nu, K):
    """ã‚¿ãƒ—ãƒ«ã¯ hashable ãªã®ã§ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¯èƒ½"""
    mu = np.array(mu_tuple)
    sigma = np.array(sigma_tuple)
    simulator = RaceSimulator(K)
    return simulator.simulate(mu, sigma, nu)
```

---

**æ¬¡ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: [09_è¨­å®šã¨ãƒ†ã‚¹ãƒˆ.md](./09_è¨­å®šã¨ãƒ†ã‚¹ãƒˆ.md)
