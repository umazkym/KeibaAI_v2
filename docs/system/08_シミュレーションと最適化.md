# 08_ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¨æœ€é©åŒ–

**æœ€çµ‚æ›´æ–°æ—¥**: 2025-11-19

---

## ğŸ“‘ ç›®æ¬¡

1. [ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³](#ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³)
2. [ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªæœ€é©åŒ–](#ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªæœ€é©åŒ–)
3. [å®Ÿè£…è©³ç´°](#å®Ÿè£…è©³ç´°)
4. [ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°](#ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°)

---

## ğŸ² ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

### ç›®çš„

Î¼, Ïƒ, Î½ã‹ã‚‰**å„é¦¬ã®å‹ç‡**ã‚’æ¨å®š

### ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

```python
for k = 1 to K (K=1000):
    for horse_i in race:
        # tåˆ†å¸ƒã‹ã‚‰ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
        time_i_k ~ t_Î½(Î¼_i, Ïƒ_iÂ²)

    # ç€é †æ±ºå®š
    finish_order = argsort(times)

    # å‹è€…è¨˜éŒ²
    winner_counts[finish_order[0]] += 1

# å‹ç‡æ¨å®š
P(win) = winner_counts / K
```

### å®Ÿè£…ï¼ˆRaceSimulatorï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `keibaai/src/modules/sim/simulator.py`

```python
import numpy as np
from scipy.stats import t

class RaceSimulator:
    def __init__(self, K=1000):
        """
        Args:
            K: ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°
        """
        self.K = K

    def simulate(
        self,
        mu_array: np.ndarray,
        sigma_array: np.ndarray,
        nu: float
    ) -> dict:
        """
        ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

        Args:
            mu_array: å„é¦¬ã®æœŸå¾…å®Œèµ°æ™‚é–“ [N]
            sigma_array: å„é¦¬ã®æ¨™æº–åå·® [N]
            nu: ãƒ¬ãƒ¼ã‚¹å…¨ä½“ã®è‡ªç”±åº¦

        Returns:
            dict: {
                'win_probs': [N],
                'place_probs': [N],
                'show_probs': [N]
            }
        """
        N = len(mu_array)
        win_counts = np.zeros(N)
        place_counts = np.zeros(N)  # 2ç€ä»¥å†…
        show_counts = np.zeros(N)   # 3ç€ä»¥å†…

        for k in range(self.K):
            # å„é¦¬ã®å®Œèµ°æ™‚é–“ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
            finish_times = np.array([
                t.rvs(df=nu, loc=mu_i, scale=sigma_i)
                for mu_i, sigma_i in zip(mu_array, sigma_array)
            ])

            # ç€é †æ±ºå®š
            finish_order = np.argsort(finish_times)

            # ã‚«ã‚¦ãƒ³ãƒˆ
            win_counts[finish_order[0]] += 1
            place_counts[finish_order[:2]] += 1
            show_counts[finish_order[:3]] += 1

        # ç¢ºç‡æ¨å®š
        win_probs = win_counts / self.K
        place_probs = place_counts / self.K
        show_probs = show_counts / self.K

        return {
            'win_probs': win_probs,
            'place_probs': place_probs,
            'show_probs': show_probs
        }
```

### é«˜é€ŸåŒ–ç‰ˆï¼ˆNumPyãƒ™ã‚¯ãƒˆãƒ«åŒ–ï¼‰

```python
def simulate_vectorized(
    self,
    mu_array: np.ndarray,
    sigma_array: np.ndarray,
    nu: float
) -> dict:
    """ãƒ™ã‚¯ãƒˆãƒ«åŒ–ç‰ˆï¼ˆ10-20xé«˜é€Ÿï¼‰"""

    N = len(mu_array)

    # ä¸€åº¦ã«å…¨ã‚µãƒ³ãƒ—ãƒ«ç”Ÿæˆ [K x N]
    finish_times_all = np.array([
        t.rvs(df=nu, loc=mu_array, scale=sigma_array, size=self.K)
        for _ in range(N)
    ]).T

    # ç€é †æ±ºå®š [K x N]
    finish_orders = np.argsort(finish_times_all, axis=1)

    # ã‚«ã‚¦ãƒ³ãƒˆ
    win_counts = np.bincount(finish_orders[:, 0], minlength=N)
    place_counts = np.bincount(finish_orders[:, :2].flatten(), minlength=N)
    show_counts = np.bincount(finish_orders[:, :3].flatten(), minlength=N)

    win_probs = win_counts / self.K
    place_probs = place_counts / self.K
    show_probs = show_counts / self.K

    return {
        'win_probs': win_probs,
        'place_probs': place_probs,
        'show_probs': show_probs
    }
```

### ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã®ä¿å­˜

```json
{
  "race_id": "202310010811",
  "race_date": "2023-10-01",
  "K": 1000,
  "nu": 5.2,
  "horses": [
    {
      "horse_number": 1,
      "horse_name": "ã‚µãƒ³ãƒ—ãƒ«ãƒ›ãƒ¼ã‚¹1",
      "mu": 72.3,
      "sigma": 1.2,
      "win_prob": 0.352,
      "place_prob": 0.681,
      "show_prob": 0.854
    },
    {
      "horse_number": 2,
      "horse_name": "ã‚µãƒ³ãƒ—ãƒ«ãƒ›ãƒ¼ã‚¹2",
      "mu": 73.1,
      "sigma": 2.1,
      "win_prob": 0.118,
      "place_prob": 0.384,
      "show_prob": 0.602
    },
    ...
  ]
}
```

---

## ğŸ’° ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªæœ€é©åŒ–

### Kelly Criterionï¼ˆã‚±ãƒªãƒ¼åŸºæº–ï¼‰

**ç™ºæ˜è€…**: John L. Kelly Jr. (1956)

**åŸºæœ¬å…¬å¼**:
```
f* = (p * (o - 1) - (1 - p)) / (o - 1)

where:
  f*: è³‡ç”£ã®ä½•å‰²ã‚’è³­ã‘ã‚‹ã‹
  p:  å‹ç‡
  o:  ã‚ªãƒƒã‚º
```

**ä¾‹**:
```python
p = 0.35  # 35%ã®å‹ç‡
o = 3.2   # 3.2å€ã®ã‚ªãƒƒã‚º

f_star = (0.35 * (3.2 - 1) - (1 - 0.35)) / (3.2 - 1)
       = (0.35 * 2.2 - 0.65) / 2.2
       = (0.77 - 0.65) / 2.2
       = 0.055  # â†’ è³‡ç”£ã®5.5%ã‚’è³­ã‘ã‚‹
```

### Fractional Kellyï¼ˆãƒªã‚¹ã‚¯èª¿æ•´ç‰ˆï¼‰

**å•é¡Œ**: Full Kellyã¯ç©æ¥µçš„ã™ãã‚‹ â†’ ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ãŒå¤§ãã„

**è§£æ±º**: Kelly fractionã§ç¸®å°

```python
f_actual = f_star * kelly_fraction

# kelly_fraction ã®æ¨å¥¨å€¤:
# 0.25: ä¿å®ˆçš„ï¼ˆæ¨å¥¨ï¼‰
# 0.50: æ¨™æº–
# 1.00: ãƒ•ãƒ«ã‚±ãƒªãƒ¼ï¼ˆãƒªã‚¹ã‚¯å¤§ï¼‰
```

### Multi-Horse Portfolio Optimization

**æœ€é©åŒ–å•é¡Œ**:
```
Maximize: Î£ f_i * log(1 + (o_i - 1) * f_i / W_0)

Subject to:
  Î£ f_i â‰¤ W_0          # è³‡æœ¬åˆ¶ç´„
  f_i â‰¥ 0              # éè² åˆ¶ç´„
  EV_i > threshold     # æœŸå¾…å€¤ãƒ•ã‚£ãƒ«ã‚¿

where:
  f_i: é¦¬iã¸ã®è³­ã‘é‡‘
  o_i: é¦¬iã®ã‚ªãƒƒã‚º
  W_0: ç·è³‡æœ¬
  EV_i = p_i * o_i - 1  # æœŸå¾…å€¤
```

### 2æ®µéšæŠ•è³‡ãƒ­ã‚¸ãƒƒã‚¯ (Two-Stage Betting Logic)

**ç›®çš„**: 1æ—¥ã®ç·äºˆç®—ã‚’åŠ¹ç‡çš„ã«é…åˆ†ã—ã¤ã¤ã€ç›´å‰ã‚ªãƒƒã‚ºã®å¤‰åŒ–ã«å¯¾å¿œã™ã‚‹ã€‚

**ãƒ•ã‚§ãƒ¼ã‚º1: æœä¸€ã®äºˆç®—é…åˆ† (Morning Allocation)**
*   **ã‚¿ã‚¤ãƒŸãƒ³ã‚°**: å½“æ—¥æœï¼ˆã¾ãŸã¯å‰æ—¥å¤œï¼‰
*   **å…¥åŠ›**: å…¨ãƒ¬ãƒ¼ã‚¹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã€æœä¸€ã‚ªãƒƒã‚ºï¼ˆã¾ãŸã¯ç¢ºå®šã‚ªãƒƒã‚ºï¼‰
*   **ãƒ­ã‚¸ãƒƒã‚¯**:
    *   å„ãƒ¬ãƒ¼ã‚¹ã®ã€Œé­…åŠ›åº¦ï¼ˆã‚¹ã‚³ã‚¢ï¼‰ã€ã‚’è¨ˆç®—ï¼ˆä¾‹: KellyåŸºæº–ã§ã®æœŸå¾…æˆé•·ç‡ã®ç·å’Œï¼‰ã€‚
    *   1æ—¥ã®ç·äºˆç®—ï¼ˆä¾‹: 1ä¸‡å††ï¼‰ã‚’ã€ã‚¹ã‚³ã‚¢ã«å¿œã˜ã¦æ¯”ä¾‹é…åˆ†ã™ã‚‹ã€‚
    *   æœŸå¾…å€¤ãŒä½ã„ãƒ¬ãƒ¼ã‚¹ã«ã¯äºˆç®—ã‚’å‰²ã‚Šå½“ã¦ãªã„ï¼ˆ0å††ï¼‰ã€‚
*   **æ‹…å½“**: `DailyAllocator`

**ãƒ•ã‚§ãƒ¼ã‚º2: ãƒ¬ãƒ¼ã‚¹ç›´å‰ã®æŠ•è³‡å®Ÿè¡Œ (Just-Before-Race Execution)**
*   **ã‚¿ã‚¤ãƒŸãƒ³ã‚°**: å„ãƒ¬ãƒ¼ã‚¹ç™ºèµ°ç›´å‰ï¼ˆä¾‹: 5åˆ†å‰ï¼‰
*   **å…¥åŠ›**: ãã®ãƒ¬ãƒ¼ã‚¹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã€**ç›´å‰ã‚ªãƒƒã‚º**ã€é…åˆ†ã•ã‚ŒãŸãƒ¬ãƒ¼ã‚¹äºˆç®—
*   **ãƒ­ã‚¸ãƒƒã‚¯**:
    *   é…åˆ†ã•ã‚ŒãŸäºˆç®—å†…ã§ã€Fractional Kelly Criterionã‚’ç”¨ã„ã¦æœ€é©ãªè²·ã„ç›®ã‚’æ±ºå®šã€‚
    *   ç›´å‰ã‚ªãƒƒã‚ºã§æœŸå¾…å€¤ãŒé–¾å€¤ã‚’ä¸‹å›ã£ãŸå ´åˆã¯ã€æŠ•è³‡ã‚’è¦‹é€ã‚‹ï¼ˆã‚¹ã‚­ãƒƒãƒ—ï¼‰ã€‚
*   **æ‹…å½“**: `PortfolioOptimizer`

---

## ğŸ’» å®Ÿè£…è©³ç´°

### æ—¥æ¬¡äºˆç®—é…åˆ†ã‚¯ãƒ©ã‚¹

**ãƒ•ã‚¡ã‚¤ãƒ«**: `keibaai/src/optimizer/daily_allocator.py`

```python
class DailyAllocator:
    def allocate_budget(self, daily_simulations, daily_odds, total_daily_budget):
        """
        1. å„ãƒ¬ãƒ¼ã‚¹ã®ã‚¹ã‚³ã‚¢ï¼ˆæœŸå¾…æˆé•·ç‡ï¼‰ã‚’è¨ˆç®—
        2. ã‚¹ã‚³ã‚¢ãŒæ­£ã®ãƒ¬ãƒ¼ã‚¹ã«äºˆç®—ã‚’æ¯”ä¾‹é…åˆ†
        """
        ...
```

### æ—¥æ¬¡æœ€é©åŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆ (çµ±åˆç‰ˆ)

**ãƒ•ã‚¡ã‚¤ãƒ«**: `keibaai/src/optimizer/optimize_daily_races.py`

```python
def main():
    # 1. å…¨ãƒ‡ãƒ¼ã‚¿ã®ãƒ­ãƒ¼ãƒ‰
    simulations = load_simulation_data(...)
    daily_odds = load_odds_data(...) # æœä¸€ã‚ªãƒƒã‚º

    # 2. äºˆç®—é…åˆ† (Phase 1)
    allocator = DailyAllocator(config)
    race_budgets = allocator.allocate_budget(simulations, daily_odds, args.W_0)

    # 3. ãƒ¬ãƒ¼ã‚¹ã”ã¨ã®å®Ÿè¡Œ (Phase 2)
    optimizer = PortfolioOptimizer(config)
    
    for sim in simulations:
        race_id = sim['race_id']
        budget = race_budgets.get(race_id, 0)
        
        if budget > 0:
            # ç›´å‰ã‚ªãƒƒã‚ºã‚’å–å¾—ï¼ˆæœ¬ç•ªã§ã¯ã“ã“ã§å†å–å¾—ï¼‰
            current_odds = get_latest_odds(race_id)
            
            # æœ€é©åŒ–å®Ÿè¡Œ
            result = optimizer.optimize(sim, current_odds, W_0=budget)
            save_order(result)
```

---

## âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°

### ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯

| K | å®Ÿè£… | æ™‚é–“ï¼ˆç§’/ãƒ¬ãƒ¼ã‚¹ï¼‰ | å€é€Ÿ |
|---|------|-----------------|------|
| 1,000 | Pythonãƒ«ãƒ¼ãƒ— | 2.5 | 1x |
| 1,000 | NumPyãƒ™ã‚¯ãƒˆãƒ«åŒ– | 0.15 | 16.7x |
| 10,000 | NumPyãƒ™ã‚¯ãƒˆãƒ«åŒ– | 1.2 | - |

### ä¸¦åˆ—åŒ–ï¼ˆè¤‡æ•°ãƒ¬ãƒ¼ã‚¹ï¼‰

```python
from multiprocessing import Pool

def simulate_single_race(args):
    race_id, mu, sigma, nu = args
    simulator = RaceSimulator(K=1000)
    return race_id, simulator.simulate(mu, sigma, nu)

# ä¸¦åˆ—å®Ÿè¡Œ
with Pool(processes=4) as pool:
    results = pool.map(simulate_single_race, race_args_list)
```

### ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def simulate_cached(mu_tuple, sigma_tuple, nu, K):
    """ã‚¿ãƒ—ãƒ«ã¯ hashable ãªã®ã§ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¯èƒ½"""
    mu = np.array(mu_tuple)
    sigma = np.array(sigma_tuple)
    simulator = RaceSimulator(K)
    return simulator.simulate(mu, sigma, nu)
```

---

**æ¬¡ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: [09_è¨­å®šã¨ãƒ†ã‚¹ãƒˆ.md](./09_è¨­å®šã¨ãƒ†ã‚¹ãƒˆ.md)
